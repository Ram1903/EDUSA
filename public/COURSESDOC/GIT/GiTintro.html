<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIT</title>
    <link rel="stylesheet" href="/COURSESDOC/COURSESINFILE.css">
    <link rel="stylesheet" href="/COURSESDOC/COURSEENDSIDE.css">
</head>

<body>
    <nav id="header">
        <div class="header container">
            <div class="nav-bar">
                <div class="brand">

                    <a href="../../home.html">
                        <h1><span>E</span>d<span>u</span>s<span>a</span></h1>
                    </a>

                </div>

            </div>
        </div>
    </nav>


    <section style="padding-top: 3rem;">




        <h1>Git and GitHub Introduction</h1>
        <h4>What is Git?</h4>
        <p>Git is a popular version control system. It was created by Linus Torvalds in 2005, and has been maintained by
            Junio Hamano since then.

            It is used for:

        <ul>
            <li>Tracking code changes</li>
            <li>Tracking who made changes</li>
            <li>Coding collaboration</li>
        </ul>
        </p>
        <h4>What does Git do?</h4>
        <p>Manage projects with Repositories
            Clone a project to work on a local copy
            Control and track changes with Staging and Committing
            Branch and Merge to allow for work on different parts and versions of a project
            Pull the latest version of the project to a local copy
            Push local updates to the main project</p>
        <h4>Working with Git</h4>
        <p>Initialize Git on a folder, making it a Repository
            Git now creates a hidden folder to keep track of changes in that folder
            When a file is changed, added or deleted, it is considered modified
            You select the modified files you want to Stage
            The Staged files are Committed, which prompts Git to store a permanent snapshot of the files
            Git allows you to see the full history of every commit.
            You can revert back to any previous commit.
            Git does not store a separate copy of every file in every commit, but keeps track of changes made in each
            commit!</p>
        <h4>Why Git?</h4>
        <p>Over 70% of developers use Git!
            Developers can work together from anywhere in the world.
            Developers can see the full history of the project.
            Developers can revert to earlier versions of a project.</p>
        <h4>What is GitHub?</h4>
        <p>Git is not the same as GitHub.
            GitHub makes tools that use Git.
            GitHub is the largest host of source code in the world, and has been owned by Microsoft since 2018.
            In this tutorial, we will focus on using Git with GitHub.
        </p>
        <h1 id="GitGettingStarted">Git Getting Started</h1>
        <h4>Git Install</h4>
        <p>You can download Git for free from the following website: https://www.git-scm.com/</p>
        <h4>Using Git with Command Line</h4>
        <p>To start using Git, we are first going to open up our Command shell.

            For Windows, you can use Git bash, which comes included in Git for Windows. For Mac and Linux you can use
            the built-in terminal.

            The first thing we need to do, is to check if Git is properly installed:</p>
        <h4>Configure Git</h4>
        <p class="tip">Note: Use global to set the username and e-mail for every repository on your computer.

            If you want to set the username/e-mail for just the current repo, you can remove global</p>
        <h4>Creating Git Folder</h4>
        <p>Now, let's create a new folder for our project:</p>
        <p>mkdir makes a new directory.

            cd changes the current working directory.

            Now that we are in the correct directory. We can start by initializing Git!</p>
        <p class="tip">Note: If you already have a folder/directory you would like to use for Git:

            Navigate to it in command line, or open it in your file explorer, right-click and select "Git Bash here"</p>
        <h4>Initialize Git</h4>
        <p>Once you have navigated to the correct folder, you can initialize Git on that folder:</p>
        <p class="tip">Note: Git now knows that it should watch the folder you initiated it on.

            Git creates a hidden folder to keep track of changes.</p>
        <h1>Git New Files</h1>
        <h4>Git Adding New Files</h4>
        <p>You just created your first local Git repo. But it is empty.

            So let's add some files, or create a new file using your favourite text editor. Then save or move it to the
            folder you just created.

            If you want to learn how to create a new file using a text editor, you can visit our HTML tutorial:
            HTML Editors

            For this example, I am going to use a simple HTML file like this:</p>
        <p>And save it to our new folder as <br>

            Let's go back to the terminal and list the files in our current working directory:</p><br>
        <p>ls will list the files in the directory. We can see that index.html is <br>

            Then we check the Git status and see if it is a part of our repo:</p>

        <p>Now Git is aware of the file, but has not added it to our repository <br>

            Files in your Git repository folder can be in one of 2 states: <br>

            Tracked - files that Git knows about and are added to the repository <br>
            Untracked - files that are in your working directory, but not added to the repository
            When you first add files to an empty repository, they are all untracked. To get Git to track them, you need
            to stage them, or add them to the staging environment.</p>

        <h1>Git Staging Environment</h1>
        <h4>Git Staging Environment</h4>
        <p>One of the core functions of Git is the concepts of the Staging Environment, and the Commit.

            As you are working, you may be adding, editing and removing files. But whenever you hit a milestone or
            finish a part of the work, you should add the files to a Staging Environment.

            Staged files are files that are ready to be committed to the repository you are working on. You will learn
            more about commit shortly.

            For now, we are done working with index.html. So we can add it to the Staging Environment:</p>
        <h4>Git Add More than One File</h4>
        <p>You can also stage more than one file at a time. Let's add 2 more files to our working folder. Use the text
            editor again.

            A README.md file that describes the repository (recommended for all repositories):</p>
        <p class="tip">Note: The shorthand command for git add --all is git add -A</p>
        <h1 id="GitCommit">Git Commit</h1>
        <h4>Git Commit</h4>
        <p>Since we have finished our work, we are ready move from stage to commit for our repo.

            Adding commits keep track of our progress and changes as we work. Git considers each commit change point or
            "save point". It is a point in the project you can go back to if you find a bug, or want to make a change.

            When we commit, we should always include a message.

            By adding clear messages to each commit, it is easy for yourself (and others) to see what has changed and
            when.</p>
        <p>The commit command performs a commit, and the -m "message" adds a message.

            The Staging Environment has been committed to our repo, with the message:
            "First release of Hello World!"</p>
        <h4>Git Commit without Stage</h4>
        <p>Sometimes, when you make small changes, using the staging environment seems like a waste of time. It is
            possible to commit changes directly, skipping the staging environment. The -a option will automatically
            stage every changed, already tracked file.

            Let's add a small update to index.html:</p>
        <div class="tip">Note: Short status flags are:

            <ul>
                <li>?? - Untracked files</li>
                <li>A - Files added to stage</li>
                <li>M - Modified files</li>
                <li>D - Deleted files</li>
              </ul></div>
        <p>We see the file we expected is modified. So let's commit it directly:</p>
        <p class="tip">Warning: Skipping the Staging Environment is not generally recommended.

            Skipping the stage step can sometimes make you include unwanted changes.</p>
        <h4>Git Commit Log</h4>
        <p>To view the history of commits for a repository, you can use the log command:</p>
        <h1>Git Branch</h1>
        
                       
            <h2>Working with Git Branches</h2>
            <p>In Git, a <code class="w3-codespan">branch</code> is a new/separate version of the main repository.</p>
            <p>Let's say you have a large project, and you need to update the design on it.</p>
            <p>How would that work without and with Git:</p>
            <p>Without Git:</p>
            <ul>
              <li>Make copies of all the relevant files to avoid impacting the live version</li>
              <li>Start working with the design and find that code depend on code in other 
              files, that also need to be changed!</li>
              <li>Make copies of the dependant files as well. Making sure that every file 
              dependency references the correct file name</li>
              <li>EMERGENCY! There is an unrelated error somewhere else in the project that 
              needs to be fixed ASAP!</li>
              <li>Save all your files, making a note of the names of the copies you were 
              working on</li>
              <li>Work on the unrelated error and update the code to fix it</li>
              <li>Go back to the design, and finish the work there</li>
              <li>Copy the code or rename the files, so the updated design is on the live 
              version</li>
              <li>(2 weeks later, you realize that the unrelated error was not fixed in the 
              new design version because you copied the files before the fix)</li>
            </ul>
            <p>With Git:</p>
            <ul>
              <li>With a new branch called new-design, edit the code directly without 
              impacting the main branch</li>
              <li>EMERGENCY! There is an unrelated error somewhere else in the project that 
              needs to be fixed ASAP!</li>
              <li>Create a new branch from the main project called small-error-fix</li>
              <li>Fix the unrelated error and merge the small-error-fix branch with the main 
              branch</li>
              <li>You go back to the new-design branch, and finish the work there</li>
              <li>Merge the new-design branch with main (getting alerted to the small error 
              fix that you were missing)</li>
            </ul>
            <p>Branches allow you to work on different parts of a project without impacting 
            the main branch.</p>
            <p>When the work is complete, a branch can be merged with the main project.</p>
            <p>You can even switch between branches and work on different projects without 
            them interfering with each other.</p>
            <p>Branching in Git is very lightweight and fast!</p>
           
        <h4>Working with Git Branches</h4>
        <p>In Git, a branch is a new/separate version of the main repository.

            Let's say you have a large project, and you need to update the design on it.

            How would that work without and with Git:

            Without Git:

            Make copies of all the relevant files to avoid impacting the live version
            Start working with the design and find that code depend on code in other files, that also need to be
            changed!
            Make copies of the dependant files as well. Making sure that every file dependency references the correct
            file name
            EMERGENCY! There is an unrelated error somewhere else in the project that needs to be fixed ASAP!
            Save all your files, making a note of the names of the copies you were working on
            Work on the unrelated error and update the code to fix it
            Go back to the design, and finish the work there
            Copy the code or rename the files, so the updated design is on the live version
            (2 weeks later, you realize that the unrelated error was not fixed in the new design version because you
            copied the files before the fix)
            With Git:

            With a new branch called new-design, edit the code directly without impacting the main branch
            EMERGENCY! There is an unrelated error somewhere else in the project that needs to be fixed ASAP!
            Create a new branch from the main project called small-error-fix
            Fix the unrelated error and merge the small-error-fix branch with the main branch
            You go back to the new-design branch, and finish the work there
            Merge the new-design branch with main (getting alerted to the small error fix that you were missing)</p>
        <h4>New Git Branch</h4>
        <p>Let add some new features to our index.html page.

            We are working in our local repository, and we do not want to disturb or possibly wreck the main project.

            So we create a new branch:</p>
        <p>Now we created a new branch called "hello-world-images"

            Let's confirm that we have created a new branch:</p>
        <p>We can see the new branch with the name "hello-world-images", but the * beside master specifies that we are
            currently on that branch.

            checkout is the command used to check out a branch. Moving us from the current branch, to the one specified
            at the end of the command:</p>
        <p>Now we have moved our current workspace from the master branch, to the new branch

            Open your favourite editor and make some changes.

            For this example, we added an image (img_hello_world.jpg) to the working folder and a line of code in the
            index.html file:</p>
        <p>We have made changes to a file and added a new file in the working directory (same directory as the main
            branch).

            Now check the status of the current branch:</p>
        <p>So let's go through what happens here:

            There are changes to our index.html, but the file is not staged for commit
            img_hello_world.jpg is not tracked
            So we need to add both files to the Staging Environment for this branch:</p>
        <h1>Git Branch Merge</h1>
        <h4>Merge Branches</h4>
        <p>We have the emergency fix ready, and so let's merge the master and emergency-fix branches.

            First, we need to change to the master branch:</p>
        <p>Now we merge the current branch (master) with emergency-fix:</p>
        <p>Since the emergency-fix branch came directly from master, and no other changes had been made to master while
            we were working, Git sees this as a continuation of master. So it can "Fast-forward", just pointing both
            master and emergency-fix to the same commit.

            As master and emergency-fix are essentially the same now, we can delete emergency-fix, as it is no longer
            needed:</p>
        <h4>Merge Conflict</h4>
        <p>Now we can move over to hello-world-images and keep working. Add another image file (img_hello_git.jpg) and
            change index.html, so it shows it:</p>
        <p>We see that index.html has been changed in both branches. Now we are ready to merge hello-world-images into
            master. But what will happen to the changes we recently made in master?</p>
        <p>The merge failed, as there is conflict between the versions for index.html. Let us check the status:</p>
        <p>This confirms there is a conflict in index.html, but the image files are ready and staged to be committed.

            So we need to fix that conflict. Open the file in our editor:</p>
        <h1>Git GitHub Edit Code</h1>
        <h4>Edit Code in GitHub</h4>
        <p>In addition to being a host for Git content, GitHub has a very good code editor.

            Let's try to edit the README.md file in GitHub. Just click the edit button:</p>
        <img src="/img/AWS/img_github_edit.png" alt="">
        <img src="/img/AWS/img_github_edit_commit.png" alt="">
        <h1>Git Pull from GitHub</h1>
        <h4>Pulling to Keep up-to-date with Changes</h4>
        <p>When working as a team on a project, it is important that everyone stays up to date.

            Any time you start working on a project, you should get the most recent changes to your local copy.

            With Git, you can do that with pull.

            pull is a combination of 2 different commands:

            fetch
            merge
            Let's take a closer look into how fetch, merge, and pull works.</p>
        <h4>Git Fetch</h4>
        <p>fetch gets all the change history of a tracked branch/repo.

            So, on your local Git, fetch updates to see what has changed on GitHub:</p>
        <h4>Git Merge</h4>
        <p>merge combines the current branch, with a specified branch.

            We have confirmed that the updates are as expected, and we can merge our current branch (master) with
            origin/master:</p>
        <h4>Git Pull</h4>
        <p>But what if you just want to update your local repository, without going through all those steps?

            pull is a combination of fetch and merge. It is used to pull all changes from a remote repository into the
            branch you are working on.

            Make another change to the Readme.md file on GitHub.</p>
        <img src="/img/AWS/img_github_create_readme2.png" alt="">
        <h1>Git Push to GitHub</h1>
        <h4>Push Changes to GitHub</h4>
        <p>Let's try making some changes to our local git and pushing them to GitHub.</p>
        <img src="/img/AWS/img_git_push_to_github.png" alt="">
        <h1>Git GitHub Branch</h1>
        <h4>Create a New Branch on GitHub</h4>
        <p>On GitHub, access your repository and click the "master" branch button.

            There you can create a new Branch. Type in a descriptive name, and click Create branch:</p>
        <img src="/img/AWS/img_github_new_branch.png" alt="">
        <img src="/img/AWS/img_github_new_branch_created.png" alt="">
        <img src="/img/AWS/img_github_edit_file.png" alt="">
        <img src="/img/AWS/img_github_edit_commit.png" alt="">
        <h1>Git Pull Branch from GitHub</h1>
        <h4>Pulling a Branch from GitHub</h4>
        <p>Now continue working on our new branch in our local Git.

            Lets pull from our GitHub repository again so that our code is up-to-date:</p>
        <p>Now our main branch is up todate. And we can see that there is a new branch available on GitHub.

            Do a quick status check:</p>
        <p>So, we do not have the new branch on our local Git. But we know it is available on GitHub. So we can use the
            -a option to see all local and remote branches:</p>
        <p class="tip">Note: branch -r is for remote branches only.</p>
        <p>We see that the branch html-skeleton is available remotely, but not on our local git. </p>
        <h1>Git Push Branch to GitHub</h1>
        <h4>Push a Branch to GitHub</h4>
        <p>Let's try to create a new local branch, and push that to GitHub.

            Start by creating a branch, like we did earlier:

        </p>
        <p>And we make some changes to the README.md file. Just add a new line.

            So now we check the status of the current branch.</p>
        <p>We see that README.md is modified but not added to the Staging Environment:</p>
        <p>Now push the branch from our local Git repository, to GitHub, where everyone can see the changes:</p>
        <img src="/img/AWS/img_git_push_branch_to_github.png" alt="">
        <img src="/img/AWS/img_github_branch_check_changes.png" alt="">
        <img src="/img/AWS/img_github_branch_create_pull_request.png" alt="">
        <img src="/img/AWS/img_github_branch_merge_pull_request.png" alt="">
        <h1>Git GitHub Flow</h1>
        <h4>Working using the GitHub Flow</h4>
        <p>On this page, you will learn how to get the best out of working with GitHub.

            The GitHub flow is a workflow designed to work well with Git and GitHub.

            It focuses on branching and makes it possible for teams to experiment freely, and make deployments
            regularly.

            The GitHub flow works like this:

            Create a new Branch
            Make changes and add Commits
            Open a Pull Request
            Review
            Deploy
            Merge
            You should already have a good understanding of how this works from the previous chapters. This chapter
            focuses on understanding how the flow makes it easy for you to work together.</p>
        <h4>Create a New Branch</h4>
        <p>Branching is the key concept in Git. And it works around the rule that the master branch is ALWAYS
            deployable.

            That means, if you want to try something new or experiment, you create a new branch! Branching gives you an
            environment where you can make changes without affecting the main branch.

            When your new branch is ready, it can be reviewed, discussed, and merged with the main branch when ready.

            When you make a new branch, you will (almost always) want to make it from the master branch.</p>
        <p class="tip">Note: Keep in mind that you are working with others. Using descriptive names for new branches, so
            everyone can understand what is happening.</p>
        <h4>Make Changes and Add Commits</h4>
        <p>After the new branch is created, it is time to get to work. Make changes by adding, editing and deleting
            files. Whenever you reach a small milestone, add the changes to your branch by commit.

            Adding commits keeps track of your work. Each commit should have a message explaining what has changed and
            why. Each commit becomes a part of the history of the branch, and a point you can revert back to if you need
            to.</p>


        <p class="tip">Note: commit messages are very important! Let everyone know what has changed and why. Messages
            and comments make it so much easier for yourself and other people to keep track of changes.</p>
        <h4>Open a Pull Request</h4>
        <p>Pull requests are a key part of GitHub. A Pull Request notifies people you have changes ready for them to
            consider or review.

            You can ask others to review your changes or pull your contribution and merge it into their branch.</p>
        <h4>Review</h4>
        <p>When a Pull Request is made, it can be reviewed by whoever has the proper access to the branch. This is where
            good discussions and review of the changes happen.

            Pull Requests are designed to allow people to work together easily and produce better results together!

            If you receive feedback and continue to improve your changes, you can push your changes with new commits,
            making further reviews possible.</p>
        <p class="tip">Note: GitHub shows new commit and feedback in the "unified Pull Request view".</p>
        <h4>Deploy
        </h4>

        <p>When the pull request has been reviewed and everything looks good, it is time for the final testing. GitHub
            allows you to deploy from a branch for final testing in production before merging with the master branch.

            If any issues arise, you can undo the changes by deploying the master branch into production again!</p>
        <p class="tip">Note: Teams often have dedicated testing environments used for deploying branches.</p>
        <h4>Merge</h4>
        <p>After exhaustive testing, you can merge the code into the master branch!

            Pull Requests keep records of changes to your code, and if you commented and named changes well, you can go
            back and understand why changes and decisions were made.</p>

        <h1>Git GitHub Pages</h1>
        <img src="/img/AWS/img_github_new_repository.png" alt="">
        <img src="/img/AWS/img_github_pages_name.png" alt="">
        <h4>Push Local Repository to GitHub Pages</h4>
        <img src="/img/AWS/img_github_pages_repository_url.png" alt="">
        <p class="tip">Note: If this is the first time you are connecting to GitHub, you will get some kind of
            notification to authenticate this connection.</p>
        <img src="/img/AWS/img_github_pages_pushed.png" alt="">
        <h1>Git GitHub Fork</h1>
        <h4>Add to Someone Else's Repository</h4>
        <p>At the heart of Git is collaboration. However, Git does not allow you to add code to someone else's
            repository without access rights.

            In these next 3 chapters we will show you how to copy a repository, make changes to it, and suggest those
            changes be implemented to the original repository.

            At the end of these chapters, you will have the opportunity to add a message to our public GitHub page:
            https://w3schools-test.github.io/</p>
        <h4>Fork a Repository</h4>
        <p>A fork is a copy of a repository. This is useful when you want to contribute to someone else's project or
            start your own project based on theirs.

            fork is not a command in Git, but something offered in GitHub and other repository hosts. Let's start by
            logging in to GitHub, and fork our repository:
            https://github.com/w3schools-test/w3schools-test.github.io</p>
        <img src="/img/AWS/img_github_fork.png" alt="">
        <img src="/img/AWS/img_github_fork_complete.png" alt="">
        <h1>Git Clone from GitHub</h1>
        <h4>Clone a Fork from GitHub</h4>
        <p>Now we have our own fork, but only on GitHub. We also want a clone on our local Git to keep working on it.

            A clone is a full copy of a repository, including all logging and versions of files.

            Move back to the original repository, and click the green "Code" button to get the URL to clone:

        </p>
        <img src="/img/AWS/img_github_clone_url.png" alt="">
        <img src="/img/AWS/img_github_clone_fork_url.png" alt="">
        <p>Now we have 2 remotes:

            origin - our own fork, where we have read and write access
            upstream - the original, where we have read-only access
            Now we are going to make some changes to the code. In the next chapter, we will cover how we suggest those
            changes to the original repository.

        </p>
        <h1>Git GitHub Send Pull Request</h1>
        <h4>Push Changes to Our GitHub Fork</h4>
        <p>Push Changes to Our GitHub Fork</p>
        <img src="/img/AWS/img_github_fork_pull_request.png" alt="">
        <h1>Git Ignore and .gitignore
        </h1>
        <h4>Git Ignore</h4>
        <p>When sharing your code with others, there are often files or parts of your project, you do not want to share.

            Examples

            log files
            temporary files
            hidden files
            personal files
            etc.
            Git can specify which files or parts of your project should be ignored by Git using a .gitignore file.

            Git will not track files and folders specified in .gitignore. However, the .gitignore file itself IS tracked
            by Git.</p>
        <h4>Create .gitignore</h4>
        <p>To create a .gitignore file, go to the root of your local Git, and create it:</p>
        <p>Now open the file using a text editor.

            We are just going to add two simple rules:

            Ignore any files with the .log extension
            Ignore everything in any directory named temp</p>
        <p class="tip">Note: In this case, we use a single .gitignore which applies to the entire repository.

            It is also possible to have additional .gitignore files in subdirectories. These only apply to files or
            folders within that directory.

        </p>
        <h4>Rules for .gitignore</h4>
        <h1 id="GitSecuritySSH">Git Security SSH</h1>
        <h4>Git Security</h4>
        <p>Up to this point, we have used HTTPS to connect to our remote repository.

            HTTPS will usually work just fine, but you should use SSH if you work with unsecured networks. And
            sometimes, a project will require that you use SSH.</p>

        <h4>What is SSH</h4>
        <p>SSH is a secure shell network protocol that is used for network management, remote file transfer, and remote
            system access.

            SSH uses a pair of SSH keys to establish an authenticated and encrypted secure network protocol. It allows
            for secure remote communication on unsecured open networks.

            SSH keys are used to initiate a secure "handshake". When generating a set of keys, you will generate a
            "public" and "private" key.

            The "public" key is the one you share with the remote party. Think of this more as the lock.

            The "private" key is the one you keep for yourself in a secure place. Think of this as the key to the lock.
        </p>
        <h4>Generating an SSH Key Pair</h4>
        <p>In the command line for Linux, Apple, and in the Git Bash for Windows, you can generate an SSH key.

            Let's go through it, step by step.

            Start by creating a new key, using your email as a label:</p>
        <p>Entering a secure passphrase will create an additional layer of security. Preventing anyone who gains access
            to the computer to use that key without the passphrase. However, it will require you to supply the
            passphrase anytime the SSH key is used.

            Now we add this SSH key pair to the SSH-Agent (using the file location from above):</p>
        <h1>Git GitHub Add SSH</h1>
        <h4>Copy the SSH Public Key</h4>
        <p>In the previous chapter, we created an SSH key pair.

            Now we will use the clip < command to copy the public key to our clipboard:</p>
                <img src="/img/AWS/img_github_profile_settings_ssh.png" alt="">
                <img src="/img/AWS/img_github_profile_settings_ssh_add.png" alt="">
                <h4>Test SSH Connection to GitHub</h4>
                <h4>Add New GitHub SSH Remote</h4>
                <p>Now we can add a new remote via SSH to our Git.

                    First, get the SSH address from our repository on GitHub:</p>
                <img src="/img/AWS/img_github_repository_code_ssh.png" alt="">
                <h1 id="GitRevert">Git Revert</h1>
                <h4>Git Revert</h4>
                <p>revert is the command we use when we want to take a previous commit and add it as a new commit,
                    keeping the log intact.

                    Step 1: Find the previous commit:</p>
                <img src="/img/AWS/img_revert_part1.gif" alt="">
                <h4>Git Revert Find Commit in Log</h4>
                <p>First thing, we need to find the point we want to return to. To do that, we need to go through the
                    log.

                    To avoid the very long log list, we are going to use the --oneline option, which gives just one line
                    per commit showing:

                    The first seven characters of the commit hash
                    the commit message
                    So let's find the point we want to revert:</p>
                <h4>Git Revert HEAD</h4>
                <p>We revert the latest commit using git revert HEAD (revert the latest change, and then commit), adding
                    the option --no-edit to skip the commit message editor (getting the default revert message):</p>
                <h1>Git Reset</h1>
                <h4>Git Reset</h4>
                <img src="/img/AWS/img_reset_part1.gif" alt="">
                <h4>Git Reset Find Commit in Log</h4>
                <p>First thing, we need to find the point we want to return to. To do that, we need to go through the
                    log.

                    To avoid the very long log list, we are going to use the --oneline option, which gives just one line
                    per commit showing:

                    The first seven characters of the commit hash - this is what we need to refer to in our reset
                    command.
                    the commit message
                    So let's find the point we want to reset to:</p>
                <h1 id="GitAmend">Git Amend</h1>
                <h4>Git commit --amend</h4>
                <p>commit --amend is used to modify the most recent commit.

                    It combines changes in the staging environment with the latest commit, and creates a new commit.

                    This new commit replaces the latest commit entirely.</p>
                <h4>Git Amend Commit Message</h4>
                <p>One of the simplest things you can do with --amend is to change a commit message.

                    Let's update the README.md and commit:</p>
                <h4>Git Amend Files</h4>
                <p>Adding files with --amend works the same way as above. Just add them to the staging environment
                    before committing.</p>







































































    </section>
    <script src="https://cdn.botpress.cloud/webchat/v1/inject.js"></script>
    <script src="https://mediafiles.botpress.cloud/bce8067a-b5f6-4be5-9f58-fc8f0344eaa0/webchat/config.js" defer></script>
</body>

</html>